(ns repl.lookup
  (:require
   [clojure.edn :as edn]
   [cognitect.transcriptor :as xr]
   [tutkain.backchannel :as backchannel]
   [tutkain.lookup :as lookup :refer [lookup]]
   [tutkain.lookup.specs :as specs]))

(def syms
  (mapcat (fn [[alias ns]]
            (map #(vector alias %) (map first (ns-publics ns))))
    (ns-aliases *ns*)))

(map (fn [[alias sym]] (lookup "repl.lookup" (str alias "/" sym))) syms)
(xr/check! ::specs/infos)

(map #(lookup "repl.lookup" (str %)) (map first (ns-refers *ns*)))
(xr/check! ::specs/infos)

(map #(lookup "clojure.main" (str %)) (map first (ns-publics 'clojure.main)))
(xr/check! ::specs/infos)

(lookup "clojure.core" "let")
(xr/check! ::specs/info)

(lookup "clojure.core" ":clojure.core.specs.alpha/binding-form")
(xr/check! ::specs/spec-info)

(require '[clojure.core.specs.alpha :as core.specs])
(lookup "repl.lookup" "::core.specs/local-name")
(xr/check! ::specs/spec-info)

(require '[clojure.spec.alpha :as spec])
(lookup "repl.lookup" "clojure.spec.alpha")
(xr/check! ::specs/ns-info)

(lookup "user" "def")
(xr/check! ::specs/info)

(lookup "nope" "mapcat")
(xr/check! ::specs/info)

(lookup/resolve-file nil)
(xr/check! nil?)

(def public-vars
  (sequence
    (comp
      (mapcat ns-publics)
      (map second))
    (all-ns)))

(xr/check! ::specs/infos
  (distinct (keep #(lookup (-> % .ns ns-name) (-> % .sym name)) public-vars)))

(->
  {:op :lookup
   :dialect :clj
   :ident "mapcat"
   :ns "user"
   :out-fn prn}
  backchannel/handle
  with-out-str
  edn/read-string
  :info)

(xr/check! ::specs/info)
