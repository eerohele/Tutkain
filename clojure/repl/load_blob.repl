(ns repl.load-blob
  (:require
   [clojure.edn :as edn]
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [tutkain.backchannel :as backchannel]
   [tutkain.backchannel.test :refer [string->base64]]
   [tutkain.load-blob])
  (:import
   (java.util.concurrent LinkedBlockingQueue TimeUnit)))

(spec/def ::tag
  #{:ret :err})

(spec/def ::val
  string?)

(spec/def ::ret
  (spec/keys :req-un [::tag ::val]))

(spec/def ::exception true?)

(spec/def ::ex-ret
  (spec/keys :req-un [::exception]))

(spec/def ::ex
  (spec/merge ::ret ::ex-ret))

(def recvq (LinkedBlockingQueue.))

(defn recv
  []
  (-> recvq (.poll 1 TimeUnit/SECONDS)))

(def eval-context (atom {}))

(backchannel/handle
  {:op :load
   :eval-lock (Object.)
   :eval-context eval-context
   :file nil
   :code (string->base64 "(defn square [x] (* x x))")
   :out-fn #(.put recvq %)})

(recv)
(xr/check! ::ret)

(backchannel/handle
  {:op :load
   :eval-lock (Object.)
   :eval-context eval-context
   :file "/my/path/math.clj"
   :code (string->base64 "(defn square [x] (* x x))")
   :out-fn #(.put recvq %)})

(recv)
(xr/check! ::ret)

(backchannel/handle
  {:op :load
   :eval-lock (Object.)
   :eval-context eval-context
   :file "/my/path/math.clj"
   :code (string->base64 "(defn square [x] (* x x)") ;; no closing paren
   :out-fn #(.put recvq %)})

(xr/check! (partial instance? Throwable) (get-in @eval-context [:thread-bindings #'*e]))

(def ex (recv))
(xr/check! ::ex ex)

(get-in @eval-context [:thread-bindings #'*e])
(ex-data *1)

(xr/check!
  #{#:clojure.error{:phase :read-source :line 1 :column 1 :source "/my/path/math.clj"}})
