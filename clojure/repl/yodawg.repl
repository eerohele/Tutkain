(ns repl.yodawg
  (:require
   [clojure.edn :as edn]
   [clojure.core.server :as server]
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [tutkain.socket :as socket]
   [tutkain.repl :as repl])
  (:import
   (clojure.lang LineNumberingPushbackReader)
   (java.io StringReader)
   (java.net ConnectException)
   (java.util.concurrent LinkedBlockingQueue TimeUnit)))

(spec/def ::tag #{:ret :err :out :tap})
(spec/def ::val string?)
(spec/def ::ns string?)
(spec/def ::ms int?)
(spec/def ::form string?)

(spec/def ::ret
  (spec/keys :opt-un [::tag ::val ::ns ::ms ::form]))

(def server-name "yodawg")

(xr/on-exit #(server/stop-server server-name))

(def server
  (do
    (server/stop-server server-name)
    (server/start-server
      {:name server-name
       :port 0
       :accept `repl/repl})))

(def rrecvq (LinkedBlockingQueue.))
(def brecvq (LinkedBlockingQueue.))

(def rsendq
  (socket/client
    :host "localhost"
    :port (.getLocalPort server)
    :recvq rrecvq))

(defn rsend
  [code]
  (.put rsendq code))

(xr/on-exit #(rsend ::socket/quit))

(defn read-forms
  [code]
  (let [EOF (Object.)]
    (when-some [reader (some->> code StringReader. LineNumberingPushbackReader.)]
      (->>
        #(read {:eof EOF :read-cond :allow} reader)
        (repeatedly)
        (take-while #(not (identical? % EOF)))))))

(defn rrecv
  []
  (-> rrecvq (.poll 1 TimeUnit/SECONDS) read-forms))

(defn brecv
  []
  (-> brecvq (.poll 1 TimeUnit/SECONDS) edn/read-string))

(def backchannel-addr (first (rrecv)))

(def bsendq
  (socket/client
    :host (:host backchannel-addr)
    :port (:port backchannel-addr)
    :recvq brecvq))

(defn bsend
  [message]
  (.put bsendq message))

(xr/on-exit #(bsend ::socket/quit))

(defmacro check-result!
  [& forms]
  `(xr/check! (into #{} '(~forms))))

;; Check that (read-line) works
;;
;; https://clojure.atlassian.net/browse/CLJ-2692
(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(read-line))
(rsend 1)
(rrecv)
(check-result! user=> "1")

(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(inc 1))
(rrecv)
(check-result! user=> 2)

(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(/ 4 0))
(rrecv)
(check-result! user=> (/ 4 0))
(brecv)
(xr/check! ::ret) ;; err

;; flush after eval
(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(print "foo"))
(rrecv)
(check-result! user=> (print "foo"))
(rrecv)
(check-result! nil)
(brecv)
(xr/check! #{{:tag :out :val "foo"}})

;; flush after eval that throws
(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(do (print "foo") (/ 4 0)))
(rrecv)
(check-result! user=> (do (print "foo") (/ 4 0)))
(rrecv)
(xr/check! nil?)
(brecv)
(xr/check! ::ret) ;; err
(brecv)
(xr/check! #{{:tag :out :val "foo"}})

(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(tap> {:foo :bar}))
(rrecv)
(check-result! user=> (tap> {:foo :bar}))
(rrecv)
(check-result! true)
(brecv)
(xr/check! ::ret) ;; tap

(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend '(Thread/sleep Integer/MAX_VALUE))
(rrecv)
(check-result! user=> (Thread/sleep Integer/MAX_VALUE))
(bsend {:op :interrupt})
(brecv)
(xr/check! ::ret) ;; InterruptedException

(bsend {:op :set-eval-context
        :file "/my/path/app.clj"
        :line 1
        :column 2
        :response {:output :clipboard}
        :id 1})

(brecv)
(rsend '(inc 1))
(brecv)
(xr/check! #{{:tag :ret :val "2\n" :output :clipboard}
             {:tag :ret :val "2\r\n" :output :clipboard}})

(bsend {:op :set-eval-context
        :file "/my/path/app.clj"
        :line 3
        :column 4
        :response {:output :clipboard}
        :id 2})

(brecv)
(rsend '(/ 4 0))
(rrecv)
(xr/check! nil?)
(brecv)
(xr/check! ::ret) ;; Error

(bsend {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(brecv)
(rsend :repl/quit)

(Thread/sleep 3000)

(try
  (socket/client
    :host (:host backchannel-addr)
    :port (:port backchannel-addr)
    :recvq brecvq)
  false
  (catch ConnectException _
    ;; Can't connect to backchannel anymore after quitting the REPL
    true))

(xr/check! true?)
