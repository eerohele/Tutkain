(ns repl.yodawg
  (:refer-clojure :exclude [send])
  (:require
   [clojure.core.server :as server]
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [tutkain.socket :as socket]
   [tutkain.repl :as repl])
  (:import
   (java.net ConnectException)))

(spec/def ::tag #{:ret :err :out :tap})
(spec/def ::val string?)
(spec/def ::ns string?)
(spec/def ::ms int?)
(spec/def ::form string?)

(spec/def ::ret
  (spec/keys :opt-un [::tag ::val ::ns ::ms ::form]))

(def server-name "yodawg")

(xr/on-exit #(server/stop-server server-name))

(def server
  (do
    (server/stop-server server-name)
    (server/start-server
      {:name server-name
       :port 0
       :accept `repl/repl})))

(def repl (socket/client :host "localhost" :port (.getLocalPort server)))
(xr/on-exit #((:stop repl)))

(def backchannel-addr ((:recv repl)))

(def backchannel (socket/client :host (:host backchannel-addr) :port (:port backchannel-addr)))
(xr/on-exit #((:stop backchannel)))

(defn recv
  [channel]
  (case channel
    :repl ((:recv repl))
    :backchannel ((:recv backchannel))))

(defn send
  [channel message]
  (case channel
    :repl ((:send repl) message)
    :backchannel ((:send backchannel) message)))

(def timeout? (partial = ::socket/timeout))

;; Smoke test
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(inc 1))
(recv :repl)
(xr/check! #{2})

;; Sending more than one form at once
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(xr/check! ::ret)
(doto (:writer repl) (.write "(inc 1) (inc 2)\n") (.flush))
(recv :repl)
(xr/check! #{2})
(recv :repl)
(xr/check! #{3})

;; Check that (read-line) works
;;
;; https://clojure.atlassian.net/browse/CLJ-2692
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(read-line))
(recv :repl)
(xr/check! timeout?)
(send :repl 1)
(recv :repl)
(xr/check! #{"1"})

;; Exceptions
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(/ 4 0))
(recv :repl)
(xr/check! timeout?)
(recv :backchannel)
(xr/check! ::ret) ;; err

;; flush after eval
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(print "foo"))
(recv :repl)
(xr/check! nil?)
(recv :backchannel)
(xr/check! #{{:tag :out :val "foo"}})

;; flush after eval that throws
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(do (print "foo") (/ 4 0)))
(recv :repl)
(xr/check! timeout?)
(recv :backchannel)
(xr/check! ::ret) ;; err
(recv :backchannel)
(xr/check! (spec/or :out #{{:tag :out :val "foo"}} :err ::ret))

;; set ns before eval
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(xr/check! ::ret)
(send :repl `(require '[clojure.set]))
(recv :repl)
(xr/check! nil?)
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'clojure.set :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl `(in-ns 'clojure.set))
(recv :repl)
(xr/check! tagged-literal?)
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'clojure.set :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(union #{1 2} #{2 3}))
(recv :repl)
(xr/check! set?)

;; create ns if it doesn't already exist
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'foo.bar :line 1 :column 1 :id 1})
(recv :backchannel)
(xr/check! ::ret)
(send :repl '(defn baz [x] (inc x)))
(.readLine (:reader repl))
(xr/check! empty?)
(.readLine (:reader repl))
(xr/check! #{"#'foo.bar/baz"})

(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(tap> {:foo :bar}))
(recv :repl)
(xr/check! true?)
(recv :backchannel)
(xr/check! ::ret) ;; tap

;; source file path in exception stack trace
(send :backchannel {:op :set-eval-context :file "/my/path/app.clj" :ns 'my.app :line 1 :column 1 :id 1})
(recv :backchannel)
(xr/check! ::ret)
(send :repl '(/ 4 0))
(recv :backchannel)
(send :backchannel {:op :set-eval-context :file "/my/path/app.clj" :ns 'my.app :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '*e)
(nth (->> (recv :repl) .form :trace (drop 2) first) 2)
(xr/check! #{"app.clj"})

;; interrupts
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(Thread/sleep Integer/MAX_VALUE))
(send :backchannel {:op :interrupt})
(recv :backchannel)
(xr/check! ::ret) ;; InterruptedException

;; *1 works
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(inc 1))
(def ret (recv :repl))
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '*1)
(recv :repl)
(xr/check! (partial = ret))

;; Switching namespace while previous eval is in progress

;; Create var in foo.bar
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'foo.bar :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(def f1 1))
(recv :repl)

;; Create var in baz.quux
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'baz.quux :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(def f2 2))
(recv :repl)

;; Eval promise in foo.bar
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'foo.bar :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(def p (promise)))
(recv :repl)
(send :repl '(deref p))

;; While previous eval is in progress, eval f2 in baz.quux
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'baz.quux :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl 'f2)
(deliver foo.bar/p :done)
(recv :repl)
(xr/check! #{:done})
(recv :repl)
(xr/check! #{2})

(send :backchannel {:op :set-eval-context
                    :file "/my/path/app.clj"
                    :line 1
                    :column 2
                    :response {:output :clipboard}
                    :id 1})

(recv :backchannel)
(send :repl '(inc 1))
(recv :backchannel)
(xr/check! #{{:tag :ret :val "2\n" :output :clipboard}
             {:tag :ret :val "2\r\n" :output :clipboard}})

(send :backchannel {:op :set-eval-context
                    :file "/my/path/app.clj"
                    :line 3
                    :column 4
                    :response {:output :clipboard}
                    :id 2})

(recv :backchannel)
(send :repl '(/ 4 0))
(recv :repl)
(xr/check! timeout?)
(recv :backchannel)
(xr/check! ::ret) ;; Error

(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl :repl/quit)

(Thread/sleep 3000)

(try
  (socket/client
    :host (:host backchannel-addr)
    :port (:port backchannel-addr))
  false
  (catch ConnectException _
    ;; Can't connect to backchannel anymore after quitting the REPL
    true))

(xr/check! true?)
