(ns repl.cljs.shadow
  (:require
   [clojure.edn :as edn]
   [clojure.core.server :as server]
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [shadow.cljs.devtools.server :as shadow.server]
   [shadow.cljs.devtools.api :as shadow.api]
   [tutkain.socket :as socket]
   [tutkain.shadow :as shadow])
  (:import
   (clojure.lang LineNumberingPushbackReader)
   (java.io StringReader)
   (java.util.concurrent LinkedBlockingQueue TimeUnit)))

(spec/def ::tag #{:ret :err :out :tap})
(spec/def ::val string?)
(spec/def ::ns string?)
(spec/def ::ms int?)
(spec/def ::form string?)

(spec/def ::ret
  (spec/keys :opt-un [::tag ::val ::ns ::ms ::form]))

(def build-id :node-script)

;; Start shadow-cljs watch

(xr/on-exit #(shadow.server/stop!))
(do (shadow.server/start!) (shadow.api/watch build-id))
#_(defn env [] (cljs/compiler-env build-id))

(def server-name "shadow")

(xr/on-exit #(server/stop-server server-name))

(def server
  (do
    (server/stop-server server-name)
    (server/start-server
      {:name server-name
       :port 0
       :accept `shadow/repl
       :args [{:build-id build-id}]})))

(def process
  (->
    (ProcessBuilder. (into-array String ["node" "out/script.js"]))
    .inheritIO
    .start))

(xr/on-exit #(.destroy process))

(Thread/sleep 3000)

(def rrecvq (LinkedBlockingQueue.))
(def brecvq (LinkedBlockingQueue.))

(def rsendq
  (socket/client
    :host "localhost"
    :port (.getLocalPort server)
    :recvq rrecvq))

(defn rsend
  [code]
  (.put rsendq code))

(xr/on-exit #(rsend ::socket/quit))

(defn read-forms
  [code]
  (let [EOF (Object.)]
    (when-some [reader (some->> code StringReader. LineNumberingPushbackReader.)]
      (->>
        #(read {:eof EOF :read-cond :allow} reader)
        (repeatedly)
        (take-while #(not (identical? % EOF)))))))

(defn rrecv
  []
  (-> rrecvq (.poll 1 TimeUnit/SECONDS) read-forms))

(defn brecv
  []
  (-> brecvq (.poll 1 TimeUnit/SECONDS) edn/read-string))

(def backchannel-addr (first (rrecv)))

(def bsendq
  (socket/client
    :host (:host backchannel-addr)
    :port (:port backchannel-addr)
    :recvq brecvq))

(defn bsend
  [message]
  (.put bsendq message))

(xr/on-exit #(bsend ::socket/quit))

(defmacro check-result!
  [& forms]
  `(xr/check! (into #{} '(~forms))))

(rsend '(inc 1))
(rrecv)
(check-result! cljs.user=> (inc 1))
(rrecv)
(check-result! 2)

(rsend '(ns foo.bar))
(rrecv)
(check-result! cljs.user=> (ns foo.bar))
(rrecv)
(check-result! nil)
(rsend (binding [*ns* (create-ns 'foo.bar)] (read-string "::qux")))
(rrecv)
(check-result! foo.bar=> :foo.bar/qux)
(rrecv)
(check-result! :foo.bar/qux)

(rsend '(ns foo.bar.baz (:import (goog.date DateTime))))
(rrecv)
(check-result! foo.bar=> (ns foo.bar.baz (:import (goog.date DateTime))))
(rrecv)
(check-result! nil)
(rsend '(DateTime.))
(rrecv)
(check-result! foo.bar.baz=> (DateTime.))
(.poll rrecvq 5 TimeUnit/SECONDS)
(xr/check! string?)

(rsend '(in-ns 'foo.bar.baz))
(rrecv)
(xr/check! nil?)

(bsend {:op :set-eval-context
        :file "/my/path/app.cljs"
        :line 1
        :column 2
        :response {:output :clipboard}
        :id 1})
(brecv)
(rsend '(js/parseInt "42"))
(rrecv)
(xr/check! nil?)
(brecv)
(xr/check! #{{:output :clipboard :tag :ret :val "42"}})

(bsend {:op :set-eval-context
        :file "/my/path/app.cljs"
        :line 3
        :column 4
        :id 2})
(brecv)
(rsend '(js/parseInt "84"))
(rrecv)
(check-result! foo.bar.baz=> (js/parseInt "84"))
(rrecv)
(check-result! 84)

(rsend :repl/quit)
(rrecv)
(check-result! foo.bar.baz=> :repl/quit)
(rrecv)
(xr/check! nil?)
