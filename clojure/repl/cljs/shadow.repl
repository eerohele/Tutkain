(ns repl.cljs.shadow
  (:refer-clojure :exclude [send])
  (:require
   [clojure.core.server :as server]
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [shadow.cljs.devtools.server :as shadow.server]
   [shadow.cljs.devtools.api :as shadow.api]
   [tutkain.socket :as socket]
   [tutkain.shadow :as shadow]))

(spec/def ::tag #{:ret :err :out :tap})
(spec/def ::val string?)
(spec/def ::ns string?)
(spec/def ::ms int?)
(spec/def ::form string?)

(spec/def ::ret
  (spec/keys :opt-un [::tag ::val ::ns ::ms ::form]))

(def build-id :node-script)

;; Start shadow-cljs watch

(xr/on-exit #(shadow.server/stop!))
(do (shadow.server/start!) (shadow.api/watch build-id))
#_(defn env [] (cljs/compiler-env build-id))

(def server-name "shadow")

(xr/on-exit #(server/stop-server server-name))

(def server
  (do
    (server/stop-server server-name)
    (server/start-server
      {:name server-name
       :port 0
       :accept `shadow/repl
       :args [{:build-id build-id}]})))

(def process
  (->
    (ProcessBuilder. (into-array String ["node" "out/script.js"]))
    .inheritIO
    .start))

(xr/on-exit #(.destroy process))

(Thread/sleep 3000)

(def repl (socket/client :host "localhost" :port (.getLocalPort server)))
(xr/on-exit #((:stop repl)))

(def backchannel-addr ((:recv repl)))

(def backchannel (socket/client :host (:host backchannel-addr) :port (:port backchannel-addr)))
(xr/on-exit #((:stop backchannel)))

(defn recv
  [channel]
  (case channel
    :repl ((:recv repl))
    :backchannel ((:recv backchannel))))

(defn send
  [channel message]
  (case channel
    :repl ((:send repl) message)
    :backchannel ((:send backchannel) message)))

(def timeout? (partial = ::socket/timeout))

;; Smoke
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(inc 1))
(recv :repl)
(xr/check! #{2})

;; Reading auto-resolved keywords
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'foo.bar :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl '(ns foo.bar))
(recv :repl)
(xr/check! nil?)
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :ns 'foo.bar :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl (binding [*ns* (create-ns 'foo.bar)] (read-string "::qux")))
(recv :repl)
(xr/check! #{:foo.bar/qux})

;; Falling back to printing a string if eval result is not readable
(comment
  ;; Disabling because of mysterious flakiness.
  (send :backchannel {:op :set-eval-context :ns 'foo.bar.baz :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
  (recv :backchannel)
  ;; This sometimes mysteriously fails in CI, never locally.
  (send :repl '(ns foo.bar.baz (:import (goog.date DateTime))))
  (recv :repl)
  (xr/check! nil?)
  (send :backchannel {:op :set-eval-context :ns 'foo.bar.baz :file "NO_SOURCE_FILE" :line 2 :column 1 :id 1})
  (recv :backchannel)
  (send :repl '(DateTime.))
  (.readLine (:reader repl))
  (.readLine (:reader repl))
  (xr/check! (every-pred string? (complement empty?))))

(with-out-str (shadow/print-result (Object.) "#object[Object 20220226T233600]"))
(xr/check! #{"#object[Object 20220226T233600]\n"
             "#object[Object 20220226T233600]\r\n"})

;; in-ns (inadequate)
(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 3 :column 1 :id 1})
(recv :backchannel)
(send :repl (read-string "(in-ns 'foo.bar.baz)"))
(recv :repl)
(xr/check! nil?)

(send :backchannel {:op :set-eval-context
                    :file "/my/path/app.cljs"
                    :line 1
                    :column 2
                    :response {:output :clipboard}
                    :id 1})

(recv :backchannel)
(send :repl '(js/parseInt "42"))
(recv :repl)
(xr/check! timeout?)
(recv :backchannel)
(xr/check! #{{:output :clipboard :tag :ret :val "42\n"}})

(send :backchannel {:op :set-eval-context
                    :file "/my/path/app.cljs"
                    :line 3
                    :column 4
                    :id 2})

(recv :backchannel)
(send :repl '(js/parseInt "84"))
(recv :repl)
(xr/check! #{84})

(send :backchannel {:op :set-eval-context :file "NO_SOURCE_FILE" :line 1 :column 1 :id 1})
(recv :backchannel)
(send :repl :repl/quit)
(recv :repl)
(xr/check! #{::socket/EOF})
