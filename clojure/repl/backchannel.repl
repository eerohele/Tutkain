(ns repl.backchannel
  (:refer-clojure :exclude [send])
  (:require
   [clojure.spec.alpha :as spec]
   [cognitect.transcriptor :as xr]
   [tutkain.backchannel :as backchannel]
   [tutkain.backchannel.test :refer [string->base64]]
   [tutkain.socket :as socket]
   [tutkain.test]))

(def eval-lock (Object.))

(let [{:keys [socket send-over-backchannel]} (backchannel/open {:port 1337 :xform-in #(assoc % :eval-lock eval-lock)})]
  (def backchannel socket)
  (def send-over-backchannel send-over-backchannel))

(xr/on-exit #(.close backchannel))
(def port (.getLocalPort backchannel))
(def client (socket/client :host "localhost" :port port))
(xr/on-exit #((:stop client)))

(defn send
  [message]
  ((:send client) message))

(defn recv
  []
  ((:recv client)))

(send {:op :echo})

(recv)
(xr/check! #{{:op :echo}})

(defmethod backchannel/handle :error
  [_]
  (throw (ex-info "Boom!" {:data :data})))

(spec/def ::tag #{:ret})
(spec/def ::exception? true?)
(spec/def ::val string?)

(spec/def ::ret
  (spec/keys :req-un [::tag ::exception ::val]))

(send {:op :error})
(recv)
(xr/check! ::ret)

;; Backchannel continues to work after handler throws an error
(send {:op :echo})
(recv)

;; Backchannel has access to the same bindings as the REPL thread
(send {:op :test
       :ns "my.test"
       :file "/path/to/my/test.clj"
       :code (string->base64 "(ns my.test (:require [clojure.test :refer [deftest is]]))
(deftest test-assert (is (true? *assert*)))")})

(spec/def ::fail empty?)
(spec/def ::type #{:pass})
(spec/def ::line #{2})
(spec/def ::pass (spec/coll-of (spec/keys :req-un [::type ::line])))

(spec/def ::test-results
  (spec/keys :req-un [::fail ::pass ::error]))

(recv)
(xr/check! ::test-results)

(send-over-backchannel {:tag :out :val "Hello, world!"})
(recv)
(xr/check! #{{:tag :out :val "Hello, world!"}})

(send {:op :quit})
(Thread/sleep 3000)
(.isClosed backchannel)
(xr/check! true?)
