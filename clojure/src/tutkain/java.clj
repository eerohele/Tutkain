(ns tutkain.java
  (:require
   [clojure.java.io :as io]
   [clojure.repl :as repl])
  (:import
   (java.net URL)))

(defn class-url->source-url
  "Given the URL of an artifact in the classpath providing Java classes, return
  the URL of the JAR that contains the source code of those classes.

  If the URL has the \"jrt\" protocol, attempt a heuristic to figure out the
  path to the ZIP file that contains the JDK source files. Otherwise, assumes
  that the source JAR has been generated by the Maven Source plugin.

  (TODO: Read actual path from artifact POM file?)

  See https://maven.apache.org/plugins/maven-source-plugin/examples/configureplugin.html."
  [^URL url]
  (when (some? url)
    (let [new-url (if (= "jrt" (.getProtocol url))
                    (str "jar:file:" (System/getProperty "java.home") "/lib/src.zip!" (.getFile url))
                    (->
                      (.toString url)
                       ;; Strip nested class part from filename
                      (.replaceAll "\\$.+?\\." "\\.")
                      (.replace ".jar!" "-sources.jar!")))]
      (URL. (.replace new-url ".class" ".java")))))

(defn resolve-stacktrace
  "Given a java.lang.Throwable, return a seq of maps representing its resolved
  stack trace.

  A \"resolved\" stack trace is one where each element of the stack trace has
  an absolute path to the source file of the stack trace element.

  For Java sources, presumes that the Java source files are next to the main
  artifact in the local Maven repository."
  [^Throwable ex]
  (when (instance? Throwable ex)
    (let [cl (.getContextClassLoader (Thread/currentThread))]
      (map (fn [el]
             (let [class-name (.getClassName el)
                   file-name (.getFileName el)
                   java? (.endsWith file-name ".java")
                   url (if java?
                         (class-url->source-url (.getResource cl (str (.replace class-name "." "/") ".class")))
                         (or
                           ;; TODO: This appears to work, but is it right?
                           (.getResource (Class/forName class-name) file-name)
                           (.getResource cl file-name)))]
               {:file (str url)
                :file-name file-name
                :column 1
                :name (if java?
                        (str (.getClassName el) "/" (.getMethodName el))
                        (repl/demunge class-name))
                ;; TODO: Why?
                ;;
                ;; {:file "jar:file:/Users/eerohe/.jabba/jdk/zulu@1.17.0-0/Contents/Home/lib/src.zip!/java.base/java/lang/Thread.java"
                ;;  :file-name "Thread.java"
                ;;  :column: 1
                ;;  :name: "java.lang.Thread/sleep"
                ;;  :line: -2}
                :line (max 0 (.getLineNumber el))}))
        (.getStackTrace ex)))))

(def ^:private result (atom nil))

(defn parse-source
  [url module-name]
  (let [tool (ToolProvider/getSystemDocumentationTool)
        file-manager (.getStandardFileManager tool nil nil nil)
        tmpdir (System/getProperty "java.io.tmpdir")
        file (io/file tmpdir (.getName (io/file (.getFile url))))
        file-objects (.getJavaFileObjectsFromFiles file-manager [file])
        doclet (reify Doclet
                 (init [this _ _]
                   (reset! result nil))
                 (run [this root]
                   (reset! result root) true)
                 (getSupportedOptions [this]
                   #{}))
        options (into
                  ["--show-members" "private"
                   "--show-types" "private"
                   "--show-packages" "all"
                   "--show-module-contents" "all"
                   "-quiet"]
                  (when module-name ["--patch-module" (format "%s=%s" module-name tmpdir)]))
        out (java.io.StringWriter.)]
    (spit file (slurp url))
    (.call (.getTask tool out file-manager nil (class doclet) options file-objects))
    @result))

(defn parse
  [environment elements]
  (into []
    (mapcat (fn [element]
              (let [trees (.getDocTrees ^DocletEnvironment environment)
                    source-positions (.getSourcePositions trees)]
                (when-some [path (.getPath trees element)]
                  (let [compilation-unit (.getCompilationUnit path)
                        line-map (.getLineMap compilation-unit)
                        position (.getStartPosition source-positions compilation-unit (.getLeaf path))
                        util (.getElementUtils environment)
                        package-name (.toString (.getPackageOf util element))
                        parent-name (-> element .getEnclosingElement .getSimpleName .toString)
                        element-name (-> element .getSimpleName .toString)
                        name (if (= (.getKind element) ElementKind/CLASS)
                               (symbol (str package-name "." element-name))
                               (symbol (str package-name "." parent-name) element-name))]
                    (into [(merge
                             {:name name
                              :line (.getLineNumber line-map position)
                              :column (.getColumnNumber line-map position)
                              :doc (some-> (.getDocComment util element) .trim)}
                             (when (= (.getKind element) ElementKind/METHOD)
                               {:arglists (mapv (fn [element]
                                                  (str "(" (.toString (.asType element)) " "(.getSimpleName element) ")"))
                                            (.getParameters element))}))]
                      (parse environment (.getEnclosedElements element))))))))
    elements))

(defn info
  [sym]
  (let [cl (.getContextClassLoader (Thread/currentThread))
        sym-class (if (qualified-symbol? sym)
                    (-> sym namespace symbol resolve)
                    (resolve sym))
        module-name (-> sym-class .getModule .getName)
        url (class-url->source-url (.getResource cl (str (.replace (.getName sym-class) "." "/") ".class")))
        environment (parse-source url module-name)
        method->info (into {}
                       (map (juxt :name identity))
                       (parse environment (.getIncludedElements environment)))]
    (some-> (get method->info sym) (assoc :format :html :file (str url)))))

(comment
  (java.time.LocalDate/parse "2021-09-28")
  (java.time.LocalDate/now)
  ,)

