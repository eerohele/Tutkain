%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
name: Clojure (Tutkain)
file_extensions: [clj]
scope: source.clojure
extends: Packages/Tutkain/EDN (Tutkain).sublime-syntax

variables:
  regexp_name: '[a-zA-Z][a-zA-Z0-9]*'

contexts:
  keywords:
    - include: auto_qualified_keyword
    - include: qualified_keyword
    - include: unqualified_keyword

  auto_qualified_keyword:
    - match: '(::)(?=[^:])({{keyword_namespace}})((/)({{keyword}})?)?'
      scope: meta.reader-form.clojure constant.other.keyword.auto-qualified.clojure
      captures:
        1: punctuation.definition.keyword.clojure
        2: meta.namespace.clojure
        4: punctuation.accessor.clojure punctuation.definition.constant.namespace.clojure

  macro_characters:
    - include: quote
    - include: character
    - include: deref
    - include: metadata
    - include: dispatch
    - include: syntax-quote
    - include: unquote

  quote:
    - match: '(''){{whitespace}}(?!\()'
      captures:
        1: keyword.operator.macro.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  deref:
    - match: '(@){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  metadata:
    - match: '(\^){{whitespace}}'
      scope: keyword.operator.macro.clojure
      push:
        - include: map
        - include: keywords
        - include: symbol
        - include: string
        - match: ''
          pop: true

  dispatch:
    - include: discard
    - include: regexp
    - include: var-quote
    - include: anonymous-function-literal
    - include: reader-conditional
    - include: tagged-element
    - include: auto-qualified-map
    - include: qualified-map

  # Dispatch

  var-quote:
    - match: '(#''){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  anonymous-function-literal:
    - match: '(#)(?=\()'
      captures:
        1: keyword.operator.macro.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  reader-conditional:
    - match: '(#\?@?){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  unquote:
    - match: '(~@?){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
        2: punctuation.definition.comma.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  syntax-quote:
    - match: '(`){{whitespace}}(?!\()'
      captures:
        1: keyword.operator.macro.clojure
        2: punctuation.definition.comma.clojure
      push:
        - include: forms
        - match: ''
          pop: true

  auto-qualified-map:
    - match: '(#)((::)({{keyword_namespace}}))'
      captures:
          1: keyword.operator.macro.clojure
          2: constant.other.keyword.auto-qualified.clojure
          3: punctuation.definition.keyword.clojure
          4: meta.namespace.clojure
      push:
        - match: '/{{symbol}}?'
          scope: invalid.illegal.edn
          pop: true
        - match: ''
          pop: true


  # S-expressions

  sexp:
    - include: quoted_list
    - include: list
    - include: vector
    - include: map
    - include: set

  # List

  quoted_list:
    - match: '([''`])\s*(\()'
      captures:
        1: keyword.operator.macro.clojure
        2: punctuation.section.parens.begin.edn
      push:
        - meta_scope: meta.sexp.list.edn
        - match: '\)'
          scope: punctuation.section.parens.end.edn
          pop: true
        - include: main

  list:
    - match: '\('
      scope: punctuation.section.parens.begin.edn
      push:
        - meta_scope: meta.sexp.list.edn
        - match: '\)'
          scope: punctuation.section.parens.end.edn
          pop: true
        - match: '{{constant}}'
          scope: meta.reader-form.edn constant.language.edn
          push:
            - match: '\)'
              scope: punctuation.section.parens.end.edn
              pop: 2
        - include: metadata
        - match: '{{qualified_symbol}}'
          captures:
            1: meta.namespace.edn
            2: punctuation.accessor.edn
          scope: meta.reader-form.clojure meta.symbol.clojure meta.function-call.clojure variable.function.clojure
          push:
            - match: '\)'
              scope: punctuation.section.parens.end.edn
              pop: 2
            - include: main
        - match: (?=\S)
          push:
            - match: '\)'
              scope: punctuation.section.parens.end.edn
              pop: 2
            - include: main
              pop: true

  symbol:
    - match: '{{qualified_symbol}}'
      scope: meta.reader-form.edn meta.symbol.edn
      captures:
        1: meta.namespace.edn
        2: punctuation.accessor.edn

  regexp_quote:
    - match: '\\Q'
      scope: punctuation.section.quotation.begin.edn
      push:
        - meta_include_prototype: false
        - meta_content_scope: constant.character.escape.regexp
        - match: '\\"'
        - match: '(?=")'
          pop: true
        - match: '\\E'
          scope: punctuation.section.quotation.end.edn
          pop: true

  regexp_shared:
    - match: '(\\)(\\|0[0-3]?[0-7]{1,2}|x\h{2}|u\h{4}|x\{1?\h{1,5}\}|\N\{[a-zA-Z0-9\- ]+\}|[tnrfae]|c[A-Z]|[dDhHsSvVwW]|p\{[a-zA-Z]+\}|b\{g\}|[bBAGZz]|[RX]|[0-9]+|k<{{regexp_name}}>|[^a-zA-Z0-9])|((\\).)'
      scope: constant.character.escape.regexp
      captures:
          1: punctuation.definition.character.escape.begin.edn
          3: invalid.illegal.escape.regexp.edn
          4: punctuation.definition.character.escape.begin.edn
    - match: '"'
      scope: punctuation.definition.string.end.edn
      pop: true
    - match: '(\[)(\^)?(-)?'
      captures:
        1: punctuation.section.brackets.begin.edn
        2: keyword.operator.negation.regexp.edn
      push:
      - meta_include_prototype: false
      - match: '(?=")'
        pop:   true
      - match: '\]'
        scope: punctuation.section.brackets.end.edn
        pop: true
      - match: '-(?!\])'
        scope: keyword.operator.range.regexp.edn
      - match: '&&'
        scope: keyword.operator.intersection.regexp.edn
      - include: regexp_shared
    - match: '(?:[?*+]|\{\d+(?:,(?:\d+)?)?\})[?+]?'
      scope: keyword.operator.quantifier.regexp.edn

  regexp_group:
    - include: regexp_quote
    - include: regexp_shared
    - match: '\|'
      scope: keyword.operator.union.regexp.edn
    - match: '(\()(\?(<{{regexp_name}}>|:|=|!|<=|<!|>|[idmsux]*(-[idmsux]+)?:|[idmsuxU]*(-[idmsuxU]+)?(?!:)))?'
      captures:
        1: punctuation.section.parens.begin.edn
        2: keyword.operator.special.regexp.edn
      push:
      - meta_include_prototype: false
      - match: '(?=")'
        pop:   true
      - match: '\)'
        scope: punctuation.section.parens.end.edn
        pop: true
      - include: regexp_group
    - match: '[\)]'
      scope: invalid.illegal.stray-bracket-end.edn

  regexp:
    - match: '(#)"'
      scope: punctuation.definition.string.begin.edn
      captures:
        1: keyword.operator.macro.edn
      push:
      - meta_include_prototype: false
      - meta_scope: meta.reader-form.edn string.regexp.edn
      - include: regexp_group
